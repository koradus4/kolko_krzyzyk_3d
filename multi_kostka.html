<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ 3D Multi-Kostka - 3 Gry Jednocze≈õnie</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3a 100%);
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .game-canvas {
            position: absolute;
            border: 3px solid;
            background-color: #000000;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        .game-active {
            border-color: #00ff88 !important;
            box-shadow: 0 0 30px rgba(0,255,136,0.5);
            z-index: 10;
        }
        
        .game-background {
            border-color: #ffaa00;
            opacity: 0.85;
            z-index: 1;
        }
        
        .game-info {
            position: absolute;
            top: -30px;
            left: 0;
            font-size: 14px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(0,0,0,0.8);
        }
        
        #totalScore {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #00ff88;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 14px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffaa00;
            max-width: 300px;
        }
        
        .instruction-key {
            display: inline-block;
            padding: 2px 6px;
            background: #333;
            border-radius: 3px;
            margin: 0 2px;
            font-family: monospace;
            color: #ffaa00;
        }
        
        #debugInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas0" class="game-canvas game-background">
            <div class="game-info">Gra #1 - Kliknij aby aktywowaƒá</div>
        </canvas>
        <canvas id="gameCanvas1" class="game-canvas game-background">
            <div class="game-info">Gra #2 - Kliknij aby aktywowaƒá</div>
        </canvas>
        <canvas id="gameCanvas2" class="game-canvas game-active">
            <div class="game-info">Gra #3 - AKTYWNA</div>
        </canvas>
        
        <div id="totalScore">üèÜ Wynik: +0</div>
        
        <div id="debugInfo">
            Aktywna gra: #3 | AI my≈õli w: 2 grach | Status: OK
        </div>
    </div>

    <script>
        class MultiCubeManager {
            constructor() {
                this.games = [];
                
                // INDEKSY GIER jak w desktop: [lewa_t≈Ço, prawa_t≈Ço, aktywna]
                this.gamePositions = [0, 1, 2];  // kt√≥re gry sƒÖ na kt√≥rych pozycjach
                this.totalScore = 0;
                
                // Pozycje gier (layout sta≈Çy)
                this.gameLayouts = {
                    backgroundLeft: { x: 50, y: 50, width: 350, height: 200 },    // Lewa g√≥ra
                    backgroundRight: { x: 450, y: 50, width: 350, height: 200 },   // Prawa g√≥ra  
                    active: { x: 150, y: 300, width: 600, height: 350 }   // Du≈ºa na dole - AKTYWNA
                };
                
                // Timery AI i ko≈Ñca gry
                this.aiTimers = [0, 0, 0];
                this.gameEndTimers = [0, 0, 0];
                this.gameEndMessages = [null, null, null];
                this.gamesInEndState = [false, false, false];
                
                this.initializeGames();
                this.setupEventListeners();
                this.animate();
            }
            
            initializeGames() {
                // Utw√≥rz 3 gry (indeksy 0, 1, 2)
                for (let i = 0; i < 3; i++) {
                    const canvas = document.getElementById(`gameCanvas${i}`);
                    const game = new MultiCube3D(canvas, i);
                    this.games.push(game);
                    
                    console.log(`üéÆ Gra #${i+1} utworzona`);
                }
                
                // Ustaw pozycje na kanvasach
                this.updateCanvasPositions();
            }
            
            updateCanvasPositions() {
                // Przypisz pozycje wed≈Çug gamePositions
                const leftGameIdx = this.gamePositions[0];   // lewa t≈Ço
                const rightGameIdx = this.gamePositions[1];  // prawa t≈Ço  
                const activeGameIdx = this.gamePositions[2]; // aktywna
                
                // Ustaw pozycje i rozmiary
                this.setCanvasLayout(leftGameIdx, this.gameLayouts.backgroundLeft, false);
                this.setCanvasLayout(rightGameIdx, this.gameLayouts.backgroundRight, false);
                this.setCanvasLayout(activeGameIdx, this.gameLayouts.active, true);
                
                console.log(`üéØ Layout: Lewa=#${leftGameIdx+1}, Prawa=#${rightGameIdx+1}, Aktywna=#${activeGameIdx+1}`);
            }
            
            setCanvasLayout(gameIdx, layout, isActive) {
                const canvas = document.getElementById(`gameCanvas${gameIdx}`);
                const game = this.games[gameIdx];
                
                // Ustaw rozmiary canvas
                canvas.width = layout.width;
                canvas.height = layout.height;
                canvas.style.left = layout.x + 'px';
                canvas.style.top = layout.y + 'px';
                canvas.style.width = layout.width + 'px';
                canvas.style.height = layout.height + 'px';
                
                // Ustaw aktywno≈õƒá
                canvas.className = isActive ? 'game-canvas game-active' : 'game-canvas game-background';
                game.setActive(isActive);
                game.updateSize(layout.width, layout.height);
            }
            
            setupEventListeners() {
                // Klikniƒôcia w gry
                this.games.forEach((game, index) => {
                    game.canvas.addEventListener('click', (event) => {
                        this.handleMouseClick(event, index);
                    });
                    
                    // Obracanie prawym przyciskiem tylko aktywnej gry
                    game.canvas.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const activeGameIdx = this.gamePositions[2];
                        if (index === activeGameIdx) {
                            game.rotationY += 0.2;
                        }
                    });
                });
                
                // Klawisze
                document.addEventListener('keydown', (e) => {
                    const activeGameIdx = this.gamePositions[2];
                    const activeGame = this.games[activeGameIdx];
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            activeGame.rotationX -= 0.1;
                            break;
                        case 'ArrowDown':
                            activeGame.rotationX += 0.1;
                            break;
                        case 'ArrowLeft':
                            activeGame.rotationY -= 0.1;
                            break;
                        case 'ArrowRight':
                            activeGame.rotationY += 0.1;
                            break;
                        case ' ':
                            activeGame.newGame();
                            e.preventDefault();
                            break;
                        case 'Escape':
                            this.resetAllGames();
                            break;
                        case '1':
                            this.activateBackgroundGame(0); // lewa
                            break;
                        case '2':
                            this.activateBackgroundGame(1); // prawa
                            break;
                    }
                });
            }
            
            // KLUCZOWA FUNKCJA: Obs≈Çuga klikniƒôƒá jak w desktop
            handleMouseClick(event, clickedGameIndex) {
                const leftGameIdx = this.gamePositions[0];   // lewa t≈Ço
                const rightGameIdx = this.gamePositions[1];  // prawa t≈Ço
                const activeGameIdx = this.gamePositions[2]; // aktywna
                
                if (clickedGameIndex === leftGameIdx) {
                    // Klikniƒôto w lewƒÖ grƒô w tle - aktywuj jƒÖ
                    this.activateBackgroundGame(0);
                    return;
                }
                
                if (clickedGameIndex === rightGameIdx) {
                    // Klikniƒôto w prawƒÖ grƒô w tle - aktywuj jƒÖ  
                    this.activateBackgroundGame(1);
                    return;
                }
                
                if (clickedGameIndex === activeGameIdx) {
                    // Klikniƒôto w aktywnƒÖ grƒô - gameplay
                    this.handleActiveGameClick(event, clickedGameIndex);
                }
            }
            
            // AKTYWACJA GRY Z T≈ÅA (jak w desktop)
            // Logika zamiany pozycji - bazowana na MouseControlledMultiGameManager
            swapPositions(pos1, pos2) {
                [this.gamePositions[pos1], this.gamePositions[pos2]] = 
                [this.gamePositions[pos2], this.gamePositions[pos1]];
                console.log(`üîÑ Zamiana pozycji ${pos1} <-> ${pos2}:`, this.gamePositions);
            }
            
            activateBackgroundGame(backgroundPosition) {
                // backgroundPosition: 0=lewa, 1=prawa
                const activeGameIdx = this.gamePositions[2]; // aktualna aktywna
                const backgroundGameIdx = this.gamePositions[backgroundPosition]; // wybrana z t≈Ça
                
                if (activeGameIdx === backgroundGameIdx) {
                    console.log(`‚ö†Ô∏è Gra #${backgroundGameIdx+1} ju≈º jest aktywna`);
                    return false;
                }
                
                // U≈ºywamy metody swapPositions jak w desktopie
                console.log(`üîÑ Zamiana: aktywna gra #${activeGameIdx+1} <-> t≈Ço gra #${backgroundGameIdx+1}`);
                this.swapPositions(2, backgroundPosition);
                
                // Aktualizuj wszystkie gry
                this.updateAllGames();
                
                const posName = backgroundPosition === 0 ? "lewƒÖ" : "prawƒÖ";
                console.log(`üñ±Ô∏è KLIKNIƒòTO: ${posName} grƒô -> Gra #${backgroundGameIdx+1} teraz AKTYWNA`);
                return true;
            }
            
            // Aktualizacja wszystkich gier po zmianie pozycji
            updateAllGames() {
                this.games.forEach((game, i) => {
                    const isActive = this.gamePositions[2] === i; // pozycja 2 to aktywna
                    game.setActive(isActive);
                });
                this.updateCanvasPositions();
                this.draw();
            }
            
            // Rysowanie wszystkich gier
            draw() {
                this.games.forEach(game => {
                    game.draw();
                });
            }
            
            // GAMEPLAY W AKTYWNEJ GRZE
            handleActiveGameClick(event, gameIndex) {
                const game = this.games[gameIndex];
                
                if (game.gameOver || game.currentPlayer !== 'X') {
                    return;
                }
                
                const rect = game.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                const field = game.getFieldFromClick(mouseX, mouseY);
                if (field && game.board[field.z][field.y][field.x] === '') {
                    game.makeMove(field.x, field.y, field.z);
                    this.aiTimers[gameIndex] = Date.now();
                    
                    console.log(`üë§ Gracz zagra≈Ç w grze #${gameIndex+1} na pozycji (${field.z},${field.y},${field.x})`);
                    
                    // AI ruch po chwili
                    if (!game.gameOver && game.currentPlayer === 'O') {
                        setTimeout(() => this.makeAIMove(gameIndex), 800);
                    }
                }
            }
            
            makeAIMove(gameIndex) {
                const game = this.games[gameIndex];
                if (game.gameOver || game.currentPlayer !== 'O') return;
                
                // DELEGUJ do mocnego AI w samej grze
                game.makeAIMove();
            }
            
            resetAllGames() {
                this.games.forEach(game => game.newGame());
                this.totalScore = 0;
                this.updateTotalScore();
                console.log('üîÑ Wszystkie gry zresetowane');
            }
            
            onGameEnd(gameIndex, winner) {
                // System punktowy jak w desktop
                if (winner === 'X') {
                    this.totalScore += 1;
                    console.log(`üèÜ Gra #${gameIndex+1}: Gracz wygrywa! (+1)`);
                } else if (winner === 'O') {
                    this.totalScore -= 1;
                    console.log(`ü§ñ Gra #${gameIndex+1}: AI wygrywa! (-1)`);
                } else {
                    console.log(`ü§ù Gra #${gameIndex+1}: Remis (0)`);
                }
                
                this.updateTotalScore();
                
                // Auto-restart po 10 sekundach jak w desktop
                this.gamesInEndState[gameIndex] = true;
                this.gameEndTimers[gameIndex] = Date.now();
                
                setTimeout(() => {
                    this.games[gameIndex].newGame();
                    this.gamesInEndState[gameIndex] = false;
                    console.log(`üîÑ Restartowanie gry #${gameIndex+1}...`);
                }, 10000);
            }
            
            updateTotalScore() {
                const scoreElement = document.getElementById('totalScore');
                const sign = this.totalScore >= 0 ? '+' : '';
                const color = this.totalScore >= 0 ? '#00ff88' : '#ff4444';
                
                scoreElement.textContent = `üèÜ Wynik: ${sign}${this.totalScore}`;
                scoreElement.style.color = color;
                scoreElement.style.borderColor = color;
            }
            
            updateDebugInfo() {
                const activeGameIdx = this.gamePositions[2];
                const aiThinkingCount = this.games.filter(game => game.currentPlayer === 'O' && !game.gameOver).length;
                
                document.getElementById('debugInfo').textContent = 
                    `Aktywna gra: #${activeGameIdx+1} | AI my≈õli w: ${aiThinkingCount} grach | Wynik: ${this.totalScore >= 0 ? '+' : ''}${this.totalScore}`;
            }
            
            animate() {
                this.games.forEach(game => game.render());
                this.updateDebugInfo();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        class MultiCube3D {
            constructor(canvas, gameIndex) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.gameIndex = gameIndex;
                this.width = canvas.width;
                this.height = canvas.height;
                this.isActive = false;
                
                // 3D parameters
                this.rotationX = 0.3;
                this.rotationY = 0.7;
                this.rotationZ = 0;
                this.cubeSize = Math.min(this.width, this.height) * 0.4;
                this.cameraDistance = 400;
                
                // Game logic
                this.board = Array(3).fill().map(() => 
                    Array(3).fill().map(() => Array(3).fill(''))
                );
                this.currentPlayer = 'X';
                this.gameOver = false;
                this.winner = null;
                this.gameScore = { player: 0, ai: 0 };
                
                console.log(`üéÆ MultiCube3D #${gameIndex+1} inicjalizowana`);
            }
            
            setActive(active) {
                this.isActive = active;
                if (active) {
                    console.log(`üéØ Gra #${this.gameIndex+1} aktywowana`);
                }
            }
            
            updateSize(width, height) {
                this.width = width;
                this.height = height;
                this.cubeSize = Math.min(width, height) * 0.4;
            }
            
            handleClick(event) {
                if (!this.isActive || this.gameOver || this.currentPlayer !== 'X') {
                    return;
                }
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                const field = this.getFieldFromClick(mouseX, mouseY);
                if (field && this.board[field.z][field.y][field.x] === '') {
                    this.makeMove(field.x, field.y, field.z);
                    
                    // AI ruch po chwili
                    if (!this.gameOver && this.currentPlayer === 'O') {
                        setTimeout(() => this.makeAIMove(), 800);
                    }
                }
            }
            
            getFieldFromClick(mouseX, mouseY) {
                const size = this.cubeSize;
                const odstep = size / 3;
                
                let bestField = null;
                let bestDistance = Infinity;
                
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        for (let z = 0; z < 3; z++) {
                            if (this.board[z][y][x] !== '') continue;
                            
                            const x3d = -odstep + x * odstep;
                            const y3d = -odstep + y * odstep;
                            const z3d = -odstep + z * odstep;
                            
                            const projected = this.project3DTo2D(x3d, y3d, z3d);
                            
                            const distance = Math.sqrt(
                                (mouseX - projected.x) ** 2 + 
                                (mouseY - projected.y) ** 2
                            );
                            
                            if (projected.z > -200 && distance < 30 && distance < bestDistance) {
                                bestDistance = distance;
                                bestField = { x, y, z };
                            }
                        }
                    }
                }
                
                return bestField;
            }
            
            makeMove(x, y, z) {
                if (this.gameOver || this.board[z][y][x] !== '') {
                    return false;
                }
                
                this.board[z][y][x] = this.currentPlayer;
                
                if (this.checkWinner()) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    
                    if (this.currentPlayer === 'X') {
                        this.gameScore.player++;
                    } else {
                        this.gameScore.ai++;
                    }
                    
                    // Powiadom manager
                    window.multiCubeManager?.onGameEnd(this.gameIndex, this.winner);
                    
                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    this.winner = null;
                    window.multiCubeManager?.onGameEnd(this.gameIndex, null);
                    
                } else {
                    this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                }
                
                return true;
            }
            
            makeAIMove() {
                if (this.gameOver || this.currentPlayer !== 'O') return;
                
                // OPENING BOOK - pierwsze ruchy strategiczne
                const moveCount = 27 - this.getEmptyFields().length;
                if (moveCount <= 2) {
                    const openingMove = this.getOpeningMove();
                    if (openingMove) {
                        this.makeMove(openingMove.x, openingMove.y, openingMove.z);
                        console.log(`üß† AI gra opening book: (${openingMove.x},${openingMove.y},${openingMove.z})`);
                        return;
                    }
                }
                
                // 1. Spr√≥buj wygraƒá (najwy≈ºszy priorytet)
                let move = this.findBestMove('O');
                if (move) {
                    this.makeMove(move.x, move.y, move.z);
                    console.log(`ü§ñ AI w grze #${this.gameIndex+1} wygrywa natychmiast!`);
                    return;
                }
                
                // 2. Zablokuj gracza przed wygranƒÖ (krytyczne!)
                move = this.findBestMove('X');
                if (move) {
                    this.makeMove(move.x, move.y, move.z);
                    console.log(`ü§ñ AI w grze #${this.gameIndex+1} blokuje wygranƒÖ gracza!`);
                    return;
                }
                
                // 3. MINIMAX - najlepszy ruch strategiczny (my≈õlenie 4-6 ruch√≥w naprz√≥d)
                move = this.findBestMoveWithMinimax();
                if (move) {
                    this.makeMove(move.x, move.y, move.z);
                    console.log(`ü§ñ AI w grze #${this.gameIndex+1} gra strategicznie (Minimax g≈Çƒôb.${move.depth || '?'}) - ocena: ${move.score}`);
                    return;
                }
                
                // 4. STRATEGICZNE CENTRUM - najlepsze pole w 3D (jesli dostƒôpne)
                if (this.board[1][1][1] === '') {
                    this.makeMove(1, 1, 1);
                    console.log(`ü§ñ AI w grze #${this.gameIndex+1} zajmuje strategiczne centrum (1,1,1)`);
                    return;
                }
                
                // 5. Ostateczno≈õƒá - losowy ruch (nie powinno siƒô zdarzyƒá)
                const empty = this.getEmptyFields();
                if (empty.length > 0) {
                    const move = empty[Math.floor(Math.random() * empty.length)];
                    this.makeMove(move.x, move.y, move.z);
                    console.log(`ü§ñ AI w grze #${this.gameIndex+1} gra losowo (ostateczno≈õƒá)`);
                }
            }
            
            // OPENING BOOK - strategiczne pierwsze ruchy
            getOpeningMove() {
                const empty = this.getEmptyFields();
                const moveCount = 27 - empty.length;
                
                if (moveCount === 0) {
                    // Pierwszy ruch AI - zawsze centrum
                    return { x: 1, y: 1, z: 1 };
                }
                
                if (moveCount === 1) {
                    // Drugi ruch - odpowied≈∫ na ruch gracza
                    
                    // Je≈õli gracz zajƒÖ≈Ç centrum - zajmij naro≈ºnik
                    if (this.board[1][1][1] === 'X') {
                        const corners = [
                            {x: 0, y: 0, z: 0}, {x: 2, y: 2, z: 2},
                            {x: 0, y: 0, z: 2}, {x: 2, y: 2, z: 0}
                        ];
                        return corners[Math.floor(Math.random() * corners.length)];
                    }
                    
                    // Je≈õli gracz zajƒÖ≈Ç naro≈ºnik - zajmij centrum
                    const corners = [[0,0,0], [0,0,2], [0,2,0], [0,2,2], [2,0,0], [2,0,2], [2,2,0], [2,2,2]];
                    for (const corner of corners) {
                        if (this.board[corner[2]][corner[1]][corner[0]] === 'X' && this.board[1][1][1] === '') {
                            return { x: 1, y: 1, z: 1 };
                        }
                    }
                    
                    // Je≈õli gracz zajƒÖ≈Ç krawƒôd≈∫/≈õcianƒô - centrum lub przeciwleg≈Çy naro≈ºnik
                    if (this.board[1][1][1] === '') {
                        return { x: 1, y: 1, z: 1 };
                    }
                    
                    // Fallback - najlepszy dostƒôpny naro≈ºnik
                    const availableCorners = corners.filter(c => 
                        this.board[c[2]][c[1]][c[0]] === ''
                    );
                    if (availableCorners.length > 0) {
                        const corner = availableCorners[0];
                        return { x: corner[0], y: corner[1], z: corner[2] };
                    }
                }
                
                return null; // Po 2 ruchach u≈ºywaj normalnej logiki
            }
            
            findBestMove(player) {
                const empty = this.getEmptyFields();
                
                for (const field of empty) {
                    // Symuluj ruch dla danego gracza
                    this.board[field.z][field.y][field.x] = player;
                    
                    // Sprawd≈∫ czy ten gracz wygrywa tym ruchem
                    const wins = this.checkWinnerForPlayer(player);
                    
                    // Cofnij ruch
                    this.board[field.z][field.y][field.x] = '';
                    
                    if (wins) return field;
                }
                
                return null;
            }
            
            // SPRAWD≈π WYGRANƒÑ DLA KONKRETNEGO GRACZA
            checkWinnerForPlayer(player) {
                const lines = this.getAllWinningLines();
                
                for (const line of lines) {
                    const [pos1, pos2, pos3] = line;
                    
                    const cell1 = this.board[pos1[2]][pos1[1]][pos1[0]];
                    const cell2 = this.board[pos2[2]][pos2[1]][pos2[0]];
                    const cell3 = this.board[pos3[2]][pos3[1]][pos3[0]];
                    
                    if (cell1 === player && cell2 === player && cell3 === player) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // MINIMAX ALGORYTM - WZMOCNIONY - my≈õlenie 4-6 ruch√≥w naprz√≥d
            findBestMoveWithMinimax() {
                const emptyFields = this.getEmptyFields();
                if (emptyFields.length === 0) return null;
                
                let bestMove = null;
                let bestScore = -Infinity;
                
                // ADAPTACYJNA G≈ÅƒòBOKO≈öƒÜ - mocniejsze AI
                let depth;
                if (emptyFields.length > 20) depth = 3;      // PoczƒÖtek gry
                else if (emptyFields.length > 15) depth = 4; // ≈örodek gry
                else if (emptyFields.length > 10) depth = 5; // P√≥≈∫ny ≈õrodek
                else depth = 6;                              // Endgame - pe≈Çna analiza
                
                console.log(`üß† AI g≈Çƒôboko≈õƒá: ${depth} (${emptyFields.length} wolnych p√≥l)`);
                
                // Priorytetyzacja ruch√≥w dla lepszej wydajno≈õci
                const prioritizedMoves = this.prioritizeMoves(emptyFields);
                
                for (const field of prioritizedMoves.slice(0, Math.min(15, prioritizedMoves.length))) {
                    // Symuluj ruch AI
                    this.board[field.z][field.y][field.x] = 'O';
                    
                    // Oblicz wynik minimax
                    const score = this.minimax(depth - 1, false, -Infinity, Infinity);
                    
                    // Cofnij ruch
                    this.board[field.z][field.y][field.x] = '';
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { ...field, score };
                    }
                }
                
                return bestMove;
            }
            
            // PRIORYTETYZACJA RUCH√ìW - najlepsze ruchy pierwsze
            prioritizeMoves(fields) {
                return fields.map(field => ({
                    ...field,
                    priority: this.evaluateMoveImportance(field)
                })).sort((a, b) => b.priority - a.priority);
            }
            
            // OCENA WA≈ªNO≈öCI RUCHU
            evaluateMoveImportance(field) {
                let priority = 0;
                
                // 1. BONUS POZYCYJNY
                const {x, y, z} = field;
                
                // Centrum (1,1,1) - najwa≈ºniejsze pole
                if (x === 1 && y === 1 && z === 1) priority += 50;
                
                // Centrum ≈õcian - bardzo wa≈ºne  
                if ((x === 1 && y === 1 && (z === 0 || z === 2)) ||
                    (x === 1 && z === 1 && (y === 0 || y === 2)) ||
                    (y === 1 && z === 1 && (x === 0 || x === 2))) {
                    priority += 30;
                }
                
                // Naro≈ºniki - kontrola przekƒÖtnych
                if ((x === 0 || x === 2) && (y === 0 || y === 2) && (z === 0 || z === 2)) {
                    priority += 25;
                }
                
                // Centrum krawƒôdzi
                if (([x,y,z].filter(coord => coord === 1).length === 1) &&
                    ([x,y,z].filter(coord => coord === 0 || coord === 2).length === 2)) {
                    priority += 15;
                }
                
                // 2. ANALIZA LINII - ile linii wp≈Çywa na to pole
                const affectedLines = this.getAffectedLines(field);
                priority += affectedLines * 2;
                
                // 3. THREAT ANALYSIS - czy ten ruch blokuje/tworzy zagro≈ºenia
                this.board[z][y][x] = 'O';
                const aiThreats = this.countThreats('O');
                this.board[z][y][x] = '';
                
                this.board[z][y][x] = 'X';
                const blockedPlayerThreats = this.countThreats('X');
                this.board[z][y][x] = '';
                
                priority += aiThreats * 10;
                priority += blockedPlayerThreats * 12; // Blokowanie wa≈ºniejsze
                
                return priority;
            }
            
            // ZLICZ ZAGRO≈ªENIA (2 w linii + 1 wolne)
            countThreats(player) {
                let threats = 0;
                const lines = this.getAllWinningLines();
                
                for (const line of lines) {
                    let playerCount = 0;
                    let emptyCount = 0;
                    
                    for (const pos of line) {
                        const cell = this.board[pos[2]][pos[1]][pos[0]];
                        if (cell === player) playerCount++;
                        else if (cell === '') emptyCount++;
                    }
                    
                    // 2 w linii + 1 wolne = zagro≈ºenie
                    if (playerCount === 2 && emptyCount === 1) {
                        threats++;
                    }
                }
                
                return threats;
            }
            
            // POLICZ LINIE WP≈ÅYWAJƒÑCE NA POLE
            getAffectedLines(field) {
                const lines = this.getAllWinningLines();
                let count = 0;
                
                for (const line of lines) {
                    for (const pos of line) {
                        if (pos[0] === field.x && pos[1] === field.y && pos[2] === field.z) {
                            count++;
                            break;
                        }
                    }
                }
                
                return count;
            }
            // MINIMAX z Alpha-Beta Pruning - WZMOCNIONY
            minimax(depth, isMaximizing, alpha, beta) {
                // Sprawd≈∫ stan gry
                const winner = this.checkWinnerForMinimax();
                if (winner === 'O') return 1000 + depth; // AI wygrywa - preferuj szybsze wygrane
                if (winner === 'X') return -1000 - depth; // Gracz wygrywa
                
                const emptyFields = this.getEmptyFields();
                if (depth === 0 || emptyFields.length === 0) {
                    // Oce≈Ñ pozycjƒô - ULEPSZONA HEURYSTYKA
                    return this.evaluateBoardAdvanced();
                }
                
                // Priorytetyzuj ruchy na ka≈ºdym poziomie
                const prioritizedFields = emptyFields.length > 8 ? 
                    this.prioritizeMoves(emptyFields).slice(0, 8) : 
                    emptyFields;
                
                if (isMaximizing) {
                    // Tura AI (maksymalizuje)
                    let maxEval = -Infinity;
                    
                    for (const field of prioritizedFields) {
                        this.board[field.z][field.y][field.x] = 'O';
                        const evaluation = this.minimax(depth - 1, false, alpha, beta);
                        this.board[field.z][field.y][field.x] = '';
                        
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        
                        if (beta <= alpha) break; // Alpha-beta pruning
                    }
                    return maxEval;
                    
                } else {
                    // Tura gracza (minimalizuje)
                    let minEval = Infinity;
                    
                    for (const field of prioritizedFields) {
                        this.board[field.z][field.y][field.x] = 'X';
                        const evaluation = this.minimax(depth - 1, true, alpha, beta);
                        this.board[field.z][field.y][field.x] = '';
                        
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        
                        if (beta <= alpha) break; // Alpha-beta pruning
                    }
                    return minEval;
                }
            }
            
            // SPRAWDZANIE WYGRANEJ dla minimax (szybsza wersja)
            checkWinnerForMinimax() {
                const lines = this.getAllWinningLines();
                
                for (const line of lines) {
                    const [pos1, pos2, pos3] = line;
                    
                    const cell1 = this.board[pos1[2]][pos1[1]][pos1[0]];
                    const cell2 = this.board[pos2[2]][pos2[1]][pos2[0]];
                    const cell3 = this.board[pos3[2]][pos3[1]][pos3[0]];
                    
                    if (cell1 && cell1 === cell2 && cell2 === cell3) {
                        return cell1; // Zwr√≥ƒá zwyciƒôzcƒô ('X' lub 'O')
                    }
                }
                
                return null; // Brak zwyciƒôzcy
            }
            
            // OCENA CA≈ÅEJ PLANSZY - ULEPSZONA WERSJA
            evaluateBoard() {
                let score = 0;
                const lines = this.getAllWinningLines();
                
                for (const line of lines) {
                    let aiCount = 0;
                    let playerCount = 0;
                    let emptyCount = 0;
                    
                    for (const pos of line) {
                        const symbol = this.board[pos[2]][pos[1]][pos[0]];
                        if (symbol === 'O') aiCount++;
                        else if (symbol === 'X') playerCount++;
                        else emptyCount++;
                    }
                    
                    // Oce≈Ñ liniƒô
                    if (playerCount === 0) { // Linia nie blokowana przez gracza
                        if (aiCount === 2) score += 20;      // AI prawie wygrywa
                        else if (aiCount === 1) score += 2;  // AI ma pozycjƒô
                    }
                    
                    if (aiCount === 0) { // Linia nie blokowana przez AI
                        if (playerCount === 2) score -= 15;  // Gracz prawie wygrywa (z≈Ça sytuacja)
                        else if (playerCount === 1) score -= 1; // Gracz ma pozycjƒô
                    }
                }
                
                // Bonus za centrum
                if (this.board[1][1][1] === 'O') score += 5;
                if (this.board[1][1][1] === 'X') score -= 3;
                
                return score;
            }
            
            // ZAAWANSOWANA OCENA PLANSZY - NOWA
            evaluateBoardAdvanced() {
                let score = 0;
                const lines = this.getAllWinningLines();
                
                // 1. ANALIZA LINII z wagami
                for (const line of lines) {
                    let aiCount = 0;
                    let playerCount = 0;
                    let emptyCount = 0;
                    let lineValue = 1;
                    
                    // Sprawd≈∫ czy linia zawiera centrum
                    let hasCenter = line.some(pos => pos[0] === 1 && pos[1] === 1 && pos[2] === 1);
                    if (hasCenter) lineValue = 2; // Linie przez centrum sƒÖ wa≈ºniejsze
                    
                    // Sprawd≈∫ czy to przekƒÖtna g≈Ç√≥wna
                    let isDiagonal = line.every(pos => pos[0] === pos[1] && pos[1] === pos[2]);
                    if (isDiagonal) lineValue = 3; // PrzekƒÖtne g≈Ç√≥wne najwa≈ºniejsze
                    
                    for (const pos of line) {
                        const symbol = this.board[pos[2]][pos[1]][pos[0]];
                        if (symbol === 'O') aiCount++;
                        else if (symbol === 'X') playerCount++;
                        else emptyCount++;
                    }
                    
                    // Ocena linii z wagami
                    if (playerCount === 0) { // AI mo≈ºe wygraƒá tƒÖ liniƒÖ
                        if (aiCount === 2) score += 50 * lineValue;  // AI prawie wygrywa!
                        else if (aiCount === 1) score += 5 * lineValue;  // AI ma pozycjƒô
                    }
                    
                    if (aiCount === 0) { // Gracz mo≈ºe wygraƒá tƒÖ liniƒÖ  
                        if (playerCount === 2) score -= 45 * lineValue; // NIEBEZPIECZE≈ÉSTWO!
                        else if (playerCount === 1) score -= 3 * lineValue; // Gracz ma pozycjƒô
                    }
                }
                
                // 2. BONUSY POZYCYJNE
                // Centrum absolutne
                if (this.board[1][1][1] === 'O') score += 30;
                else if (this.board[1][1][1] === 'X') score -= 20;
                
                // Centra ≈õcian - kontrola 3D
                const facesCenters = [[1,1,0], [1,1,2], [1,0,1], [1,2,1], [0,1,1], [2,1,1]];
                for (const center of facesCenters) {
                    if (this.board[center[2]][center[1]][center[0]] === 'O') score += 15;
                    else if (this.board[center[2]][center[1]][center[0]] === 'X') score -= 10;
                }
                
                // Naro≈ºniki - kontrola przekƒÖtnych  
                const corners = [[0,0,0], [0,0,2], [0,2,0], [0,2,2], [2,0,0], [2,0,2], [2,2,0], [2,2,2]];
                for (const corner of corners) {
                    if (this.board[corner[2]][corner[1]][corner[0]] === 'O') score += 8;
                    else if (this.board[corner[2]][corner[1]][corner[0]] === 'X') score -= 5;
                }
                
                // 3. MOBILITY - ile ruch√≥w ma ka≈ºdy gracz
                const aiMobility = this.countValidMoves('O');
                const playerMobility = this.countValidMoves('X');
                score += (aiMobility - playerMobility) * 2;
                
                return score;
            }
            
            // ZLICZ DOSTƒòPNE RUCHY
            countValidMoves(player) {
                let moves = 0;
                const empty = this.getEmptyFields();
                
                for (const field of empty) {
                    this.board[field.z][field.y][field.x] = player;
                    
                    // Sprawd≈∫ czy ten ruch tworzy zagro≈ºenie
                    const threats = this.countThreats(player);
                    if (threats > 0) moves += 2; // Zagra≈ºajƒÖce ruchy warte wiƒôcej
                    else moves += 1;
                    
                    this.board[field.z][field.y][field.x] = '';
                }
                
                return moves;
            }
            
            getEmptyFields() {
                const empty = [];
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        for (let z = 0; z < 3; z++) {
                            if (this.board[z][y][x] === '') {
                                empty.push({ x, y, z });
                            }
                        }
                    }
                }
                return empty;
            }
            
            isBoardFull() {
                return this.getEmptyFields().length === 0;
            }
            
            checkWinner() {
                const player = this.currentPlayer;
                const lines = this.getAllWinningLines();
                
                for (const line of lines) {
                    const [pos1, pos2, pos3] = line;
                    
                    const cell1 = this.board[pos1[2]][pos1[1]][pos1[0]];
                    const cell2 = this.board[pos2[2]][pos2[1]][pos2[0]];
                    const cell3 = this.board[pos3[2]][pos3[1]][pos3[0]];
                    
                    if (cell1 && cell1 === cell2 && cell2 === cell3 && cell1 === player) {
                        return true;
                    }
                }
                
                return false;
            }
            
            getAllWinningLines() {
                const lines = [];
                
                // Wszystkie 49 linii wygrywajƒÖcych
                for (let z = 0; z < 3; z++) {
                    for (let y = 0; y < 3; y++) {
                        lines.push([[0,y,z], [1,y,z], [2,y,z]]);
                    }
                }
                
                for (let z = 0; z < 3; z++) {
                    for (let x = 0; x < 3; x++) {
                        lines.push([[x,0,z], [x,1,z], [x,2,z]]);
                    }
                }
                
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        lines.push([[x,y,0], [x,y,1], [x,y,2]]);
                    }
                }
                
                for (let z = 0; z < 3; z++) {
                    lines.push([[0,0,z], [1,1,z], [2,2,z]]);
                    lines.push([[2,0,z], [1,1,z], [0,2,z]]);
                }
                
                for (let x = 0; x < 3; x++) {
                    lines.push([[x,0,0], [x,1,1], [x,2,2]]);
                    lines.push([[x,2,0], [x,1,1], [x,0,2]]);
                }
                
                for (let y = 0; y < 3; y++) {
                    lines.push([[0,y,0], [1,y,1], [2,y,2]]);
                    lines.push([[2,y,0], [1,y,1], [0,y,2]]);
                }
                
                lines.push([[0,0,0], [1,1,1], [2,2,2]]);
                lines.push([[2,0,0], [1,1,1], [0,2,2]]);
                lines.push([[0,2,0], [1,1,1], [2,0,2]]);
                lines.push([[2,2,0], [1,1,1], [0,0,2]]);
                
                return lines;
            }
            
            newGame() {
                this.board = Array(3).fill().map(() => 
                    Array(3).fill().map(() => Array(3).fill(''))
                );
                this.currentPlayer = 'X';
                this.gameOver = false;
                this.winner = null;
                
                console.log(`üîÑ Gra #${this.gameIndex+1} zresetowana`);
            }
            
            rotatePoint(x, y, z) {
                let cosX = Math.cos(this.rotationX);
                let sinX = Math.sin(this.rotationX);
                let y1 = y * cosX - z * sinX;
                let z1 = y * sinX + z * cosX;
                
                let cosY = Math.cos(this.rotationY);
                let sinY = Math.sin(this.rotationY);
                let x2 = x * cosY + z1 * sinY;
                let z2 = -x * sinY + z1 * cosY;
                
                let cosZ = Math.cos(this.rotationZ);
                let sinZ = Math.sin(this.rotationZ);
                let x3 = x2 * cosZ - y1 * sinZ;
                let y3 = x2 * sinZ + y1 * cosZ;
                
                return { x: x3, y: y3, z: z2 };
            }
            
            project3DTo2D(x, y, z) {
                const rotated = this.rotatePoint(x, y, z);
                const perspective = this.cameraDistance / (this.cameraDistance + rotated.z);
                
                const screenX = this.width / 2 + rotated.x * perspective;
                const screenY = this.height / 2 + rotated.y * perspective;
                
                return { 
                    x: screenX, 
                    y: screenY, 
                    z: rotated.z,
                    perspective: perspective 
                };
            }
            
            drawLine3D(x1, y1, z1, x2, y2, z2, color = 'white', lineWidth = 2) {
                const p1 = this.project3DTo2D(x1, y1, z1);
                const p2 = this.project3DTo2D(x2, y2, z2);
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.setLineDash([]);
                
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.lineTo(p2.x, p2.y);
                this.ctx.stroke();
            }
            
            render() {
                // Clear
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const size = this.cubeSize;
                const odstep = size / 3;
                const lineColor = this.isActive ? '#FFFFFF' : '#888888';
                
                // Linie szkieletu
                for (let z = 0; z < 3; z++) {
                    for (let y = 0; y < 3; y++) {
                        const z3d = -odstep + z * odstep;
                        const y3d = -odstep + y * odstep;
                        
                        this.drawLine3D(-odstep, y3d, z3d, odstep, y3d, z3d, lineColor, 1);
                    }
                }
                
                for (let z = 0; z < 3; z++) {
                    for (let x = 0; x < 3; x++) {
                        const z3d = -odstep + z * odstep;
                        const x3d = -odstep + x * odstep;
                        
                        this.drawLine3D(x3d, -odstep, z3d, x3d, odstep, z3d, lineColor, 1);
                    }
                }
                
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        const y3d = -odstep + y * odstep;
                        const x3d = -odstep + x * odstep;
                        
                        this.drawLine3D(x3d, y3d, -odstep, x3d, y3d, odstep, lineColor, 1);
                    }
                }
                
                // 27 kwadracik√≥w
                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        for (let z = 0; z < 3; z++) {
                            const x3d = -odstep + x * odstep;
                            const y3d = -odstep + y * odstep;
                            const z3d = -odstep + z * odstep;
                            
                            const projected = this.project3DTo2D(x3d, y3d, z3d);
                            
                            if (projected.z > -200) {
                                const squareSize = (this.isActive ? 15 : 10) * projected.perspective;
                                
                                // Kwadrat
                                this.ctx.fillStyle = this.isActive ? 'rgba(80,80,100,0.8)' : 'rgba(60,60,80,0.6)';
                                this.ctx.fillRect(
                                    projected.x - squareSize/2,
                                    projected.y - squareSize/2,
                                    squareSize,
                                    squareSize
                                );
                                
                                // Ramka
                                this.ctx.strokeStyle = this.isActive ? 'rgba(220,220,220,0.8)' : 'rgba(150,150,150,0.5)';
                                this.ctx.lineWidth = 1;
                                this.ctx.strokeRect(
                                    projected.x - squareSize/2,
                                    projected.y - squareSize/2,
                                    squareSize,
                                    squareSize
                                );
                                
                                // Symbol
                                const symbol = this.board[z][y][x];
                                if (symbol) {
                                    this.ctx.fillStyle = symbol === 'X' ? '#FF9650' : '#32A0FF';
                                    this.ctx.font = `bold ${Math.floor((this.isActive ? 16 : 12) * projected.perspective)}px Arial`;
                                    this.ctx.textAlign = 'center';
                                    this.ctx.fillText(symbol, projected.x, projected.y + 4 * projected.perspective);
                                }
                            }
                        }
                    }
                }
                
                // Status gry
                this.ctx.fillStyle = this.isActive ? 'white' : '#888';
                this.ctx.font = this.isActive ? '14px Arial' : '12px Arial';
                this.ctx.textAlign = 'left';
                
                // Wynik lokalny
                this.ctx.fillText(
                    `${this.gameScore.player}-${this.gameScore.ai}`, 
                    10, this.height - 40
                );
                
                // Status
                if (this.gameOver) {
                    this.ctx.fillStyle = this.winner === 'X' ? '#00ff88' : 
                                       this.winner === 'O' ? '#ff4444' : '#ffaa00';
                    this.ctx.font = this.isActive ? 'bold 16px Arial' : 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    
                    const statusText = this.winner === 'X' ? 'WYGRANA!' : 
                                      this.winner === 'O' ? 'AI WYGRYWA' : 'REMIS';
                    this.ctx.fillText(statusText, this.width/2, this.height - 60);
                    
                } else if (this.isActive) {
                    this.ctx.fillStyle = this.currentPlayer === 'X' ? '#00ff88' : '#ff4444';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'center';
                    
                    const playerText = this.currentPlayer === 'X' ? 'Twoja kolej!' : 'AI my≈õli...';
                    this.ctx.fillText(playerText, this.width/2, this.height - 20);
                }
            }
        }
        
        // Inicjalizacja
        window.onload = () => {
            window.multiCubeManager = new MultiCubeManager();
            console.log('üéÆ Multi-Cube Manager gotowy!');
            console.log('üéØ Kliknij w gry w tle aby je aktywowaƒá!');
        };
    </script>
</body>
</html>